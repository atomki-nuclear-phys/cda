// Dear emacs, this is -*- c++ -*-
// $Id$
#ifndef CDA_CORE_DEVICE_CRATE_ICC
#define CDA_CORE_DEVICE_CRATE_ICC

// Qt include(s):
#include <QtCore/QIODevice>
#include <QtCore/QDataStream>
#include <QtXml/QDomNode>
#include <QtXml/QDomElement>

// Local include(s):
#include "Loader.h"

namespace dev {

   //
   // Make sure that the following Qt classes are available in the
   // current namespace even if Qt has been built in an arbitrary
   // namespace:
   //
   using QT_PREPEND_NAMESPACE( QIODevice );
   using QT_PREPEND_NAMESPACE( QDataStream );
   using QT_PREPEND_NAMESPACE( QDomNode );
   using QT_PREPEND_NAMESPACE( QDomElement );

   /**
    * The constructor expects a function pointer to one of the functions of
    * dev::Factory. The specified function will later on be used to create
    * the new device objects when reading a configuration. You should
    * construct the object something like this:
    *
    * <code>
    *   dev::Crate< dev::Hist >( &dev::Factory::createHist );
    * </code>
    *
    * @param factoryFncn Function pointer to one of dev::Factory's functions
    */
   template< class DEVICE >
   Crate< DEVICE >::Crate()
      : m_devices(), m_loader( 0 ),
        m_logger( "dev::Crate" ) {

   }

   /**
    * The destructor clears the configuration before destroying the object,
    * so the handled devices wouldn't be leaked.
    */
   template< class DEVICE >
   Crate< DEVICE >::~Crate() {

      clear();
   }

   template< class DEVICE >
   bool Crate< DEVICE >::readConfig( QIODevice* dev ) {

      // Check that a correct loader is set:
      if( ! checkLoader() ) return false;

      m_logger << msg::VERBOSE
               << tr( "Reading configuration from binary input" )
               << msg::endmsg;

      clear();

      QDataStream input( dev );
      input.setVersion( QDataStream::Qt_4_0 );

      quint32 nDevices;
      input >> nDevices;

      for( quint32 i = 0; i < nDevices; ++i ) {

         QString type;
         input >> type;

         if( m_loader->isLoaded( type ) ) {

            Factory* factory = m_loader->getFactory( type );
            DEVICE* device = factory->createDevice< DEVICE >();
            if( ! device ) continue;
            if( ! device->readConfig( dev ) ) {
               m_logger << msg::ERROR
                        << tr( "There was a problem reading the "
                               "configuration of one of the devices!" )
                        << msg::endmsg;
               delete device;
               return false;
            }

            /*
            if( ! ( ( device->getSlot() > 0 ) &&
                    ( device->getSlot() <= NUMBER_OF_SLOTS ) ) ) {
               m_logger << msg::ERROR
                        << tr( "There was a problem reading the "
                               "configuration of one of the devices!" )
                        << msg::endmsg;
               delete device;
               return false;
            }
            */

            typename std::map< unsigned int, DEVICE* >::iterator it;
            if( ( it = m_devices.find( device->getID() ) ) !=
                m_devices.end() ) {
               m_logger << msg::WARNING
                        << tr( "Redefining the device with 'id': %1" )
                  .arg( device->getID() ) << msg::endmsg;
               delete it->second;
            }

            m_devices[ device->getID() ] = device;

         } else {
            m_logger << msg::ERROR
                     << tr( "Device type \"%1\" unknown.\n"
                            "Check that you have all plugins available!" )
               .arg( type ) << msg::endmsg;
            return false;
         }

      }

      return true;
   }

   template< class DEVICE >
   bool Crate< DEVICE >::writeConfig( QIODevice* dev ) const {

      m_logger << msg::VERBOSE << tr( "Writing configuration to binary output" )
               << msg::endmsg;

      QDataStream output( dev );
      output.setVersion( QDataStream::Qt_4_0 );
      output << ( quint32 ) m_devices.size();

      for( typename std::map< unsigned int, DEVICE* >::const_iterator device_it =
              m_devices.begin(); device_it != m_devices.end();
           ++device_it ) {

         output << device_it->second->deviceName();
         if( ! device_it->second->writeConfig( dev ) ) {
            m_logger << msg::ERROR
                     << tr( "There was a problem writing the "
                            "configuration of a device" )
                     << msg::endmsg;
            return false;
         }

      }

      return true;
   }

   template< class DEVICE >
   bool Crate< DEVICE >::readConfig( const QDomElement& element ) {

      // Check that a correct loader is set:
      if( ! checkLoader() ) return false;

      m_logger << msg::VERBOSE << tr( "Reading configuration from XML input" )
               << msg::endmsg;

      clear();

      for( int i = 0; i < element.childNodes().size(); ++i ) {

         if( ! element.childNodes().at( i ).isElement() ) continue;

         QString type = element.childNodes().at( i ).nodeName();

         if( m_loader->isLoaded( type ) ) {

            Factory* factory = m_loader->getFactory( type );
            DEVICE* device = factory->createDevice< DEVICE >();
            if( ! device->readConfig( element.childNodes().at( i ).toElement() ) ) {
               m_logger << msg::ERROR
                        << tr( "There was a problem reading the "
                               "configuration of one of the devices!" )
                        << msg::endmsg;
               delete device;
               return false;
            }

            /*
            if( ! ( ( device->getSlot() > 0 ) &&
                    ( device->getSlot() <= NUMBER_OF_SLOTS ) ) ) {
               m_logger << msg::ERROR
                        << tr( "There was a problem reading the "
                               "configuration of one of the devices!" )
                        << msg::endmsg;
               delete device;
               return false;
            }
            */

            typename std::map< unsigned int, DEVICE* >::iterator it;
            if( ( it = m_devices.find( device->getID() ) ) !=
                m_devices.end() ) {
               m_logger << msg::WARNING
                        << tr( "Redefining the device with 'id': %1" )
                  .arg( device->getID() )
                        << msg::endmsg;
               delete it->second;
            }

            m_devices[ device->getID() ] = device;

         } else {
            m_logger << msg::ERROR
                     << tr( "Device type \"%1\" unknown\n"
                            "Check that you have all plugins available!" )
               .arg( type )
                     << msg::endmsg;
            return false;
         }

      }

      return true;
   }

   template< class DEVICE >
   bool Crate< DEVICE >::writeConfig( QDomElement& element ) const {

      m_logger << msg::VERBOSE << tr( "Writing configuration to XML output" )
               << msg::endmsg;

      for( typename std::map< unsigned int, DEVICE* >::const_iterator device_it =
              m_devices.begin(); device_it != m_devices.end();
           ++device_it ) {

         QDomElement dev_element =
            element.ownerDocument().createElement( device_it->second->deviceName() );
         if( ! device_it->second->writeConfig( dev_element ) ) {
            m_logger << msg::ERROR
                     << tr( "There was a problem writing the "
                            "configuration of a device" )
                     << msg::endmsg;
            return false;
         }
         element.appendChild( dev_element );

      }

      return true;
   }

   template< class DEVICE >
   Loader* Crate< DEVICE >::getLoader() const {

      return m_loader;
   }

   /**
    * A correctly configured dev::Loader object is used by the class to access
    * the dev::Factory objects for each supported CAMAC device. It is not
    * possible to load a configuration without giving such a dev::Loader object
    * to the class, so it should be done just after creating the object.
    *
    * @param loader Pointer to a correctly configured dev::Loader object
    */
   template< class DEVICE >
   void Crate< DEVICE >::setLoader( const Loader* loader ) {

      m_loader = loader;
      return;
   }

   /**
    * The function deletes all the device objects and resets the map storing
    * them.
    */
   template< class DEVICE >
   void Crate< DEVICE >::clear() {

      for( typename std::map< unsigned int, DEVICE* >::iterator device_it =
              m_devices.begin(); device_it != m_devices.end();
           ++device_it ) {
         delete device_it->second;
      }
      m_devices.clear();

      return;
   }

   /**
    * The function doesn't do much for the moment, it just checks that the
    * pointer to the dev::Loader object is not a null-pointer. It could be
    * made smarter later on...
    *
    * @returns <code>true</code> if a correct dev::Loader is set,
    *          <code>false</code> otherwise
    */
   template< class DEVICE >
   bool Crate< DEVICE >::checkLoader() const {

      if( ! m_loader ) {
         m_logger << msg::ERROR
                  << tr( "No functional dev::Loader object specified yet\n"
                         "Configuration reading is not possible like this!" )
                  << msg::endmsg;
         return false;
      }

      return true;
   }

} // namespace dev

#endif // CDA_CORE_DEVICE_CRATE_ICC
