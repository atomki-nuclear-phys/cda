// Dear emacs, this is -*- c++ -*-
// $Id$
#ifndef CDA_CORE_DEVICE_CRATE_ICC
#define CDA_CORE_DEVICE_CRATE_ICC

// Qt include(s):
#include <QtCore/QIODevice>
#include <QtCore/QDataStream>
#include <QtXml/QDomElement>

// Local include(s):
#include "Loader.h"

namespace dev {

   //
   // Make sure that the following Qt classes are available in the
   // current namespace even if Qt has been built in an arbitrary
   // namespace:
   //
   using QT_PREPEND_NAMESPACE( QIODevice );
   using QT_PREPEND_NAMESPACE( QDataStream );
   using QT_PREPEND_NAMESPACE( QDomElement );

   /**
    * The constructor expects a function pointer to one of the functions of
    * dev::Factory. The specified function will later on be used to create
    * the new device objects when reading a configuration. You should
    * construct the object something like this:
    *
    * <code>
    *   dev::Crate< dev::Hist >( &dev::Factory::createHist );
    * </code>
    *
    * @param factoryFncn Function pointer to one of dev::Factory's functions
    */
   template< class DEVICE >
   Crate< DEVICE >::Crate( const QString& type )
      : m_devices(), m_loader( 0 ), m_type( type ),
        m_logger( "dev::Crate" ) {

   }

   /**
    * The destructor clears the configuration before destroying the object,
    * so the handled devices wouldn't be leaked.
    */
   template< class DEVICE >
   Crate< DEVICE >::~Crate() {

      clear();
   }

   template< class DEVICE >
   bool Crate< DEVICE >::readConfig( QIODevice* dev ) {

      // Check that a correct loader is set:
      if( ! checkLoader() ) return false;

      m_logger << msg::VERBOSE
               << tr( "Reading configuration from binary input" )
               << msg::endmsg;

      clear();

      QDataStream input( dev );
      input.setVersion( QDataStream::Qt_4_0 );

      // Check if the configuration is of the right type:
      QString type;
      input >> type;
      if( type != m_type ) {
         m_logger << msg::ERROR
                  << tr( "Wrong type found in configuration (%1 != %2) "
                         "You may be reading a too old XML file, or "
                         "a configuration meant for a different application." )
            .arg( type ).arg( m_type )
                  << msg::endmsg;
         return false;
      }

      quint32 nDevices;
      input >> nDevices;

      for( quint32 i = 0; i < nDevices; ++i ) {

         QString type;
         input >> type;

         if( m_loader->isLoaded( type ) ) {

            Factory* factory = m_loader->getFactory( type );
            DEVICE* device = factory->createDevice< DEVICE >();
            if( ! device ) continue;
            if( ! device->readConfig( dev ) ) {
               m_logger << msg::ERROR
                        << tr( "There was a problem reading the "
                               "configuration of one of the devices!" )
                        << msg::endmsg;
               delete device;
               return false;
            }

            typename std::map< unsigned int, DEVICE* >::iterator it;
            if( ( it = m_devices.find( device->getID() ) ) !=
                m_devices.end() ) {
               m_logger << msg::WARNING
                        << tr( "Redefining the device with 'id': %1" )
                  .arg( device->getID() ) << msg::endmsg;
               delete it->second;
            }

            m_devices[ device->getID() ] = device;

         } else {
            m_logger << msg::ERROR
                     << tr( "Device type \"%1\" unknown.\n"
                            "Check that you have all plugins available!" )
               .arg( type ) << msg::endmsg;
            return false;
         }

      }

      // Let the derived classes read in their specific configuration:
      if( ! readCrateConfig( dev ) ) {
         m_logger << msg::ERROR
                  << tr( "Failed to read crate specific configuration" )
                  << msg::endmsg;
         return false;
      }

      return true;
   }

   template< class DEVICE >
   bool Crate< DEVICE >::writeConfig( QIODevice* dev ) const {

      m_logger << msg::VERBOSE << tr( "Writing configuration to binary output" )
               << msg::endmsg;

      QDataStream output( dev );
      output.setVersion( QDataStream::Qt_4_0 );
      output << m_type;
      output << ( quint32 ) m_devices.size();

      typename std::map< unsigned int, DEVICE* >::const_iterator itr =
         m_devices.begin();
      typename std::map< unsigned int, DEVICE* >::const_iterator end =
         m_devices.end();
      for( ; itr != end; ++itr ) {

         output << itr->second->deviceName();
         if( ! itr->second->writeConfig( dev ) ) {
            m_logger << msg::ERROR
                     << tr( "There was a problem writing the "
                            "configuration of a device" )
                     << msg::endmsg;
            return false;
         }

      }

      // Let the derived classes write out their specific configuration:
      if( ! writeCrateConfig( dev ) ) {
         m_logger << msg::ERROR
                  << tr( "Failed to write crate specific configuration" )
                  << msg::endmsg;
         return false;
      }

      return true;
   }

   template< class DEVICE >
   bool Crate< DEVICE >::readConfig( const QDomElement& element ) {

      // Check that a correct loader is set:
      if( ! checkLoader() ) return false;

      m_logger << msg::VERBOSE << tr( "Reading configuration from XML input" )
               << msg::endmsg;

      clear();

      // Find the element describing the crate:
      int crate_index = -1;
      for( int i = 0; i < element.childNodes().size(); ++i ) {

         if( ! element.childNodes().at( i ).isElement() ) continue;

         if( element.childNodes().at( i ).nodeName() == m_type ) {
            crate_index = i;
            break;
         }
      }
      if( crate_index == -1 ) {
         m_logger << msg::ERROR
                  << tr( "Couldn't find crate element in XML. "
                         "You may be reading a too old XML file, or "
                         "a configuration meant for a different application." )
                  << msg::endmsg;
         return false;
      }

      // Access the DOM node:
      QDomElement crate_element =
         element.childNodes().at( crate_index ).toElement();

      // Let the derived classes read in their specific configuration:
      if( ! readCrateConfig( crate_element ) ) {
         m_logger << msg::ERROR
                  << tr( "Failed to read crate specific configuration" )
                  << msg::endmsg;
         return false;
      }

      for( int i = 0; i < crate_element.childNodes().size(); ++i ) {

         if( ! crate_element.childNodes().at( i ).isElement() ) continue;

         const QString type = crate_element.childNodes().at( i ).nodeName();

         if( m_loader->isLoaded( type ) ) {

            Factory* factory = m_loader->getFactory( type );
            DEVICE* device = factory->createDevice< DEVICE >();
            if( ! device->readConfig( crate_element.childNodes().at( i ).toElement() ) ) {
               m_logger << msg::ERROR
                        << tr( "There was a problem reading the "
                               "configuration of one of the devices!" )
                        << msg::endmsg;
               delete device;
               return false;
            }

            typename std::map< unsigned int, DEVICE* >::iterator it;
            if( ( it = m_devices.find( device->getID() ) ) !=
                m_devices.end() ) {
               m_logger << msg::WARNING
                        << tr( "Redefining the device with 'id': %1" )
                  .arg( device->getID() )
                        << msg::endmsg;
               delete it->second;
            }

            m_devices[ device->getID() ] = device;

         } else {
            m_logger << msg::ERROR
                     << tr( "Device type \"%1\" unknown\n"
                            "Check that you have all plugins available!" )
               .arg( type )
                     << msg::endmsg;
            return false;
         }

      }

      return true;
   }

   template< class DEVICE >
   bool Crate< DEVICE >::writeConfig( QDomElement& element ) const {

      m_logger << msg::VERBOSE << tr( "Writing configuration to XML output" )
               << msg::endmsg;

      // Create a top level element for the whole crate:
      QDomElement crate_element =
         element.ownerDocument().createElement( m_type );

      // Let the derived classes write out their specific configuration:
      if( ! writeCrateConfig( crate_element ) ) {
         m_logger << msg::ERROR
                  << tr( "Failed to write crate specific configuration" )
                  << msg::endmsg;
         return false;
      }
      element.appendChild( crate_element );

      typename std::map< unsigned int, DEVICE* >::const_iterator itr =
         m_devices.begin();
      typename std::map< unsigned int, DEVICE* >::const_iterator end =
         m_devices.end();
      for( ; itr != end; ++itr ) {

         QDomElement dev_element =
            element.ownerDocument().createElement( itr->second->deviceName() );
         if( ! itr->second->writeConfig( dev_element ) ) {
            m_logger << msg::ERROR
                     << tr( "There was a problem writing the "
                            "configuration of a device" )
                     << msg::endmsg;
            return false;
         }
         crate_element.appendChild( dev_element );

      }

      return true;
   }

   template< class DEVICE >
   bool Crate< DEVICE >::canRead( QIODevice* dev ) const {

      QDataStream input( dev );
      input.setVersion( QDataStream::Qt_4_0 );

      // Check if the configuration is of the right type:
      QString type;
      input >> type;
      if( type == m_type ) {
         return true;
      } else {
         return false;
      }
   }

   template< class DEVICE >
   bool Crate< DEVICE >::canRead( const QDomElement& node ) const {

      for( int i = 0; i < node.childNodes().size(); ++i ) {

         if( ! node.childNodes().at( i ).isElement() ) continue;

         if( node.childNodes().at( i ).nodeName() == m_type ) {
            return true;
         }
      }

      return false;
   }

   template< class DEVICE >
   Loader* Crate< DEVICE >::getLoader() const {

      return m_loader;
   }

   /**
    * A correctly configured dev::Loader object is used by the class to access
    * the dev::Factory objects for each supported CAMAC device. It is not
    * possible to load a configuration without giving such a dev::Loader object
    * to the class, so it should be done just after creating the object.
    *
    * @param loader Pointer to a correctly configured dev::Loader object
    */
   template< class DEVICE >
   void Crate< DEVICE >::setLoader( const Loader* loader ) {

      m_loader = loader;
      return;
   }

   /**
    * The function deletes all the device objects and resets the map storing
    * them.
    */
   template< class DEVICE >
   void Crate< DEVICE >::clear() {

      for( typename std::map< unsigned int, DEVICE* >::iterator device_it =
              m_devices.begin(); device_it != m_devices.end();
           ++device_it ) {
         delete device_it->second;
      }
      m_devices.clear();

      return;
   }

   /**
    * The function doesn't do much for the moment, it just checks that the
    * pointer to the dev::Loader object is not a null-pointer. It could be
    * made smarter later on...
    *
    * @returns <code>true</code> if a correct dev::Loader is set,
    *          <code>false</code> otherwise
    */
   template< class DEVICE >
   bool Crate< DEVICE >::checkLoader() const {

      if( ! m_loader ) {
         m_logger << msg::ERROR
                  << tr( "No functional dev::Loader object specified yet\n"
                         "Configuration reading is not possible like this!" )
                  << msg::endmsg;
         return false;
      }

      return true;
   }

   template< class DEVICE >
   bool Crate< DEVICE >::readCrateConfig( QIODevice* ) {

      return true;
   }

   template< class DEVICE >
   bool Crate< DEVICE >::writeCrateConfig( QIODevice* ) const {

      return true;
   }

   template< class DEVICE >
   bool Crate< DEVICE >::readCrateConfig( const QDomElement& ) {

      return true;
   }

   template< class DEVICE >
   bool Crate< DEVICE >::writeCrateConfig( QDomElement& ) const {

      return true;
   }

} // namespace dev

#endif // CDA_CORE_DEVICE_CRATE_ICC
